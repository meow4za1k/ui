-- Zync.pmo UI Library
-- A minimalist gaming menu UI with tab system and script toggles

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")

-- Create the library table
local ZyncLib = {}
ZyncLib.__index = ZyncLib

-- Constants
local HIGHLIGHT_COLOR = Color3.fromRGB(81, 81, 189)
local DEFAULT_TEXT_COLOR = Color3.fromRGB(255, 255, 255)
local UNSELECTED_COLOR = Color3.fromRGB(200, 200, 200)
local KEYBIND_COLOR = Color3.fromRGB(150, 150, 150)
local DROPDOWN_BG_COLOR = Color3.fromRGB(30, 30, 30)

-- Sound IDs
local SOUND_IDS = {
    hover = "rbxassetid://4681278859", -- Soft hover sound
    click = "rbxassetid://5942420465", -- Light click sound
    toggleOn = "rbxassetid://6042583705", -- Toggle on sound
    toggleOff = "rbxassetid://6042583723", -- Toggle off sound
    nav = "rbxassetid://255473262" -- Navigation sound
}

-- Create a new instance of the library
function ZyncLib.new(title)
    local self = setmetatable({}, ZyncLib)
    
    -- Library properties
    self.title = title or "Zync.pmo"
    self.width = 200
    self.tabs = {}
    self.activeTab = nil
    self.commonKeybinds = {"F", "G", "H", "J", "K", "Z", "X", "C", "V", "B", "1", "2", "3", "4", "5"}
    
    -- UI state
    self.state = {
        menuEnabled = true,
        minimized = false,
        selectedTab = 1,
        selectedOption = 0,
        isDragging = false,
        dragOffset = nil,
        expandedTabs = {},
        keybindOpen = false,
        lastHoveredElement = nil
    }
    
    -- Script manager for toggle functionality
    self.scriptManager = {
        running = {}
    }
    
    -- Create the sound system
    self:InitSounds()
    
    -- Create the UI
    self:CreateUI()
    
    return self
end

-- Initialize sound system
function ZyncLib:InitSounds()
    -- Create sound group
    self.soundGroup = Instance.new("SoundGroup")
    self.soundGroup.Name = "ZyncSounds"
    self.soundGroup.Parent = SoundService
    
    -- Create sound objects
    self.sounds = {}
    
    for name, id in pairs(SOUND_IDS) do
        local sound = Instance.new("Sound")
        sound.Name = name .. "Sound"
        sound.SoundId = id
        sound.Volume = (name == "hover") and 0.2 or 0.3
        sound.PlayOnRemove = false
        sound.SoundGroup = self.soundGroup
        sound.Parent = self.soundGroup
        
        self.sounds[name] = sound
    end
end

-- Play a sound with option to clone (for overlapping sounds)
function ZyncLib:PlaySound(name)
    local sound = self.sounds[name]
    if not sound then return end
    
    -- Clone the sound to allow overlapping
    local soundClone = sound:Clone()
    soundClone.Parent = self.soundGroup
    soundClone:Play()
    
    -- Auto-cleanup
    soundClone.Ended:Connect(function()
        soundClone:Destroy()
    end)
end

-- Create the main UI elements
function ZyncLib:CreateUI()
    -- Create ScreenGui
    self.screenGui = Instance.new("ScreenGui")
    self.screenGui.Name = "ZyncMenuGui"
    self.screenGui.ResetOnSpawn = false
    self.screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    self.screenGui.DisplayOrder = 999
    self.screenGui.IgnoreGuiInset = true
    
    -- Try to parent to CoreGui, fallback to PlayerGui
    pcall(function()
        if RunService:IsStudio() then
            self.screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
        else
            self.screenGui.Parent = game.CoreGui
        end
    end)
    
    if not self.screenGui.Parent then
        self.screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Create glow container
    self.glowContainer = Instance.new("Frame")
    self.glowContainer.Name = "GlowContainer"
    self.glowContainer.BackgroundTransparency = 1
    self.glowContainer.BorderSizePixel = 0
    self.glowContainer.Position = UDim2.new(0, 6, 0, 6)
    self.glowContainer.Size = UDim2.new(0, self.width + 8, 0, 208)
    self.glowContainer.ZIndex = 998
    self.glowContainer.Parent = self.screenGui
    
    -- Create black glow effect
    for i = 1, 3 do
        local shadowLayer = Instance.new("Frame")
        shadowLayer.Name = "ShadowLayer_" .. i
        shadowLayer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        shadowLayer.BorderSizePixel = 0
        shadowLayer.Position = UDim2.new(0, -i, 0, -i)
        shadowLayer.Size = UDim2.new(1, i*2, 1, i*2)
        shadowLayer.BackgroundTransparency = 0.7 + (i * 0.1)
        shadowLayer.ZIndex = 997 - i
        shadowLayer.Parent = self.glowContainer
    end
    
    -- Create main frame
    self.mainFrame = Instance.new("Frame")
    self.mainFrame.Name = "MainFrame"
    self.mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    self.mainFrame.BackgroundTransparency = 0.2
    self.mainFrame.BorderSizePixel = 0
    self.mainFrame.Position = UDim2.new(0, 10, 0, 10)
    self.mainFrame.Size = UDim2.new(0, self.width, 0, 200)
    self.mainFrame.ZIndex = 999
    self.mainFrame.Parent = self.screenGui
    
    -- Create drag handle
    self.dragHandle = Instance.new("Frame")
    self.dragHandle.Name = "DragHandle"
    self.dragHandle.BackgroundTransparency = 1
    self.dragHandle.Position = UDim2.new(0, 0, 0, 0)
    self.dragHandle.Size = UDim2.new(1, 0, 0, 20)
    self.dragHandle.ZIndex = 1000
    self.dragHandle.Parent = self.mainFrame
    
    -- Create title
    self.titleLabel = Instance.new("TextLabel")
    self.titleLabel.Name = "TitleLabel"
    self.titleLabel.BackgroundTransparency = 1
    self.titleLabel.Position = UDim2.new(0, 5, 0, 5)
    self.titleLabel.Size = UDim2.new(1, -10, 0, 15)
    self.titleLabel.Font = Enum.Font.RobotoMono
    self.titleLabel.Text = self.title
    self.titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    self.titleLabel.TextSize = 14
    self.titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.titleLabel.ZIndex = 1000
    self.titleLabel.Parent = self.mainFrame
    
    -- Create separator
    self.separator = Instance.new("Frame")
    self.separator.Name = "Separator"
    self.separator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.separator.BorderSizePixel = 0
    self.separator.Position = UDim2.new(0, 5, 0, 20)
    self.separator.Size = UDim2.new(1, -10, 0, 1)
    self.separator.ZIndex = 1000
    self.separator.Parent = self.mainFrame
    
    -- Create menu container
    self.menuContainer = Instance.new("ScrollingFrame")
    self.menuContainer.Name = "MenuContainer"
    self.menuContainer.BackgroundTransparency = 1
    self.menuContainer.Position = UDim2.new(0, 5, 0, 25)
    self.menuContainer.Size = UDim2.new(1, -10, 1, -30)
    self.menuContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    self.menuContainer.ScrollBarThickness = 0
    self.menuContainer.ScrollingDirection = Enum.ScrollingDirection.Y
    self.menuContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
    self.menuContainer.ZIndex = 1000
    self.menuContainer.Parent = self.mainFrame
    
    -- Create keybind dropdown (initially hidden)
    self.keybindDropdown = Instance.new("Frame")
    self.keybindDropdown.Name = "KeybindDropdown"
    self.keybindDropdown.BackgroundColor3 = DROPDOWN_BG_COLOR
    self.keybindDropdown.BorderSizePixel = 0
    self.keybindDropdown.Position = UDim2.new(0, 0, 0, 0)
    self.keybindDropdown.Size = UDim2.new(0, 120, 0, 100)
    self.keybindDropdown.Visible = false
    self.keybindDropdown.ZIndex = 1100
    self.keybindDropdown.Parent = self.screenGui
    
    -- Set up input handlers and animation
    self:SetupInputHandlers()
    self:StartShadowAnimation()
end

-- Start shadow animation
function ZyncLib:StartShadowAnimation()
    spawn(function()
        local pulseAmount = 0.05
        local pulseSpeed = 0.5
        local counter = 0
        
        while self.screenGui and self.screenGui.Parent and wait(0.03) do
            counter = counter + 0.05
            local pulseFactor = (math.sin(counter * pulseSpeed) + 1) / 2 * pulseAmount
            
            for i, layer in ipairs(self.glowContainer:GetChildren()) do
                if not self.state.isDragging and not self.state.minimized then
                    layer.BackgroundTransparency = 0.7 + (i * 0.1) - pulseFactor
                end
            end
        end
    end)
end

-- Set up input handlers
function ZyncLib:SetupInputHandlers()
    -- Make UI draggable
    self.dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.state.isDragging = true
            self.state.dragOffset = Vector2.new(
                input.Position.X - self.mainFrame.AbsolutePosition.X,
                input.Position.Y - self.mainFrame.AbsolutePosition.Y
            )
            self:PlaySound("click")
        end
    end)
    
    self.dragHandle.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.state.isDragging = false
            self.state.dragOffset = nil
        end
    end)
    
    -- Mouse movement for dragging
    UserInputService.InputChanged:Connect(function(input)
        if self.state.isDragging and self.state.dragOffset and input.UserInputType == Enum.UserInputType.MouseMovement then
            local newPosition = UDim2.new(
                0, 
                input.Position.X - self.state.dragOffset.X,
                0, 
                input.Position.Y - self.state.dragOffset.Y
            )
            self.mainFrame.Position = newPosition
            self.glowContainer.Position = UDim2.new(
                0,
                newPosition.X.Offset - 4,
                0,
                newPosition.Y.Offset - 4
            )
        end
    end)
    
    -- Set up title double-click for minimize
    self.titleLabel.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Check for double click (less than 0.5 seconds between clicks)
            if self.titleLabel.LastClickTime and tick() - self.titleLabel.LastClickTime < 0.5 then
                self:ToggleMinimized()
                self.titleLabel.LastClickTime = nil
            else
                self.titleLabel.LastClickTime = tick()
                self:PlaySound("click")
            end
        end
    end)
    
    -- Add hover sound to title
    self.titleLabel.MouseEnter:Connect(function()
        if self.state.lastHoveredElement ~= self.titleLabel then
            self:PlaySound("hover")
            self.state.lastHoveredElement = self.titleLabel
        end
    end)
    
    -- Set up keyboard navigation
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not self.state.menuEnabled then return end
        
        if input.KeyCode == Enum.KeyCode.Home then
            -- Toggle menu visibility
            self:ToggleVisibility()
        elseif input.KeyCode == Enum.KeyCode.Up then
            -- Move selection up
            self:Navigate(-1)
        elseif input.KeyCode == Enum.KeyCode.Down then
            -- Move selection down
            self:Navigate(1)
        elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.Space then
            -- Select current option (both Enter and Space keys work)
            self:HandleSelect()
        end
        
        -- Check for keybind press
        for tabIndex, tab in ipairs(self.tabs) do
            for optionIndex, option in ipairs(tab.options) do
                if option.keybind then
                    local keyName = string.upper(option.keybind)
                    local keyCode = Enum.KeyCode[keyName]
                    if keyCode and input.KeyCode == keyCode then
                        self.state.selectedTab = tabIndex
                        self.state.selectedOption = optionIndex
                        self:CycleOptionValue(tabIndex, optionIndex)
                        self:Render()
                    end
                end
            end
        end
    end)
    
    -- Set up mouse wheel scrolling
    UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if gameProcessed or not self.state.menuEnabled or self.state.minimized then return end
        
        if input.UserInputType == Enum.UserInputType.MouseWheel then
            if input.Position.Z > 0 then
                -- Scroll up
                self:Navigate(-1)
            else
                -- Scroll down
                self:Navigate(1)
            end
        end
    end)
end

-- Script Manager Methods
function ZyncLib.scriptManager:RunScript(id, onFn, offFn)
    if self.running[id] then
        self:StopScript(id)
        return false
    else
        -- Store script data
        self.running[id] = {
            connections = {},
            cleanupFns = {},
            offFn = offFn
        }
        
        -- Execute the script
        if typeof(onFn) == "function" then
            local env = getfenv(onFn)
            
            -- Add helper functions to environment
            env.RegisterConnection = function(conn)
                table.insert(self.running[id].connections, conn)
                return conn
            end
            
            env.RegisterCleanup = function(fn)
                table.insert(self.running[id].cleanupFns, fn)
                return fn
            end
            
            env.CreateLoop = function(interval, fn)
                local running = true
                local conn
                
                if interval < 0.01 then
                    conn = RunService.RenderStepped:Connect(function(dt)
                        if running then fn(dt) end
                    end)
                else
                    conn = spawn(function()
                        while running and wait(interval) do
                            fn(interval)
                        end
                    end)
                end
                
                table.insert(self.running[id].cleanupFns, function()
                    running = false
                    if typeof(conn) == "RBXScriptConnection" then
                        conn:Disconnect()
                    end
                end)
                
                return {
                    Stop = function()
                        running = false
                        if typeof(conn) == "RBXScriptConnection" then
                            conn:Disconnect()
                        end
                    end
                }
            end
            
            -- Run the script
            local success, result = pcall(onFn)
            if not success then
                warn("Script execution error: " .. tostring(result))
            end
        end
        
        return true
    end
end

function ZyncLib.scriptManager:StopScript(id)
    local scriptData = self.running[id]
    if scriptData then
        -- Disconnect all connections
        for _, conn in ipairs(scriptData.connections) do
            if typeof(conn) == "RBXScriptConnection" and conn.Connected then
                conn:Disconnect()
            end
        end
        
        -- Run cleanup functions
        for _, fn in ipairs(scriptData.cleanupFns) do
            pcall(fn)
        end
        
        -- Run off script if provided
        if scriptData.offFn and typeof(scriptData.offFn) == "function" then
            pcall(scriptData.offFn)
        end
        
        -- Remove from running scripts
        self.running[id] = nil
        return true
    end
    return false
end

-- Handle selection (Enter/Space key)
function ZyncLib:HandleSelect()
    if self.state.selectedOption == 0 then
        -- Toggle tab expansion
        self:ToggleTab(self.state.selectedTab)
        self:PlaySound("click")
    else
        -- Toggle option value
        self:CycleOptionValue(self.state.selectedTab, self.state.selectedOption)
    end
    
    self:Render()
end

-- Add a new tab
function ZyncLib:AddTab(name)
    local tab = {
        name = name,
        expanded = (#self.tabs == 0), -- First tab is expanded by default
        options = {}
    }
    
    table.insert(self.tabs, tab)
    
    -- Update expanded tabs state
    if #self.tabs == 1 then
        self.state.expandedTabs[1] = true
    else
        self.state.expandedTabs[#self.tabs] = false
    end
    
    -- Set as active tab if it's the first one
    if #self.tabs == 1 then
        self.activeTab = tab
    end
    
    -- Render the UI
    self:Render()
    
    -- Return the tab object for chaining
    return {
        -- Add toggle option
        AddToggle = function(optName, settings)
            settings = settings or {}
            return self:AddToggle(#self.tabs, optName, settings)
        end,
        
        -- Add dropdown option
        AddDropdown = function(optName, settings)
            settings = settings or {}
            return self:AddDropdown(#self.tabs, optName, settings)
        end,
        
        -- Add button option
        AddButton = function(optName, settings)
            settings = settings or {}
            return self:AddButton(#self.tabs, optName, settings)
        end
    }
end

-- Add toggle option to a tab
function ZyncLib:AddToggle(tabIndex, name, settings)
    settings = settings or {}
    
    local option = {
        name = name,
        type = "toggle",
        value = settings.default or "« OFF",
        values = {"« OFF", "« ON"},
        keybind = settings.keybind,
        scriptId = settings.scriptId or (self.tabs[tabIndex].name .. "_" .. name),
        onScript = settings.onScript,
        offScript = settings.offScript,
        callback = settings.callback
    }
    
    table.insert(self.tabs[tabIndex].options, option)
    self:Render()
    
    return option
end

-- Add dropdown option to a tab
function ZyncLib:AddDropdown(tabIndex, name, settings)
    settings = settings or {}
    
    local values = settings.values or {"Option 1", "Option 2", "Option 3"}
    local option = {
        name = name,
        type = "dropdown",
        value = settings.default or values[1],
        values = values,
        keybind = settings.keybind,
        scriptId = settings.scriptId or (self.tabs[tabIndex].name .. "_" .. name),
        onScript = settings.onScript,
        offScript = settings.offScript,
        callback = settings.callback
    }
    
    table.insert(self.tabs[tabIndex].options, option)
    self:Render()
    
    return option
end

-- Add button option to a tab
function ZyncLib:AddButton(tabIndex, name, settings)
    settings = settings or {}
    
    local option = {
        name = name,
        type = "button",
        keybind = settings.keybind,
        scriptId = settings.scriptId or (self.tabs[tabIndex].name .. "_" .. name),
        callback = settings.callback or function() end
    }
    
    table.insert(self.tabs[tabIndex].options, option)
    self:Render()
    
    return option
end

-- Toggle tab expansion
function ZyncLib:ToggleTab(tabIndex)
    self.state.expandedTabs[tabIndex] = not self.state.expandedTabs[tabIndex]
    self:Render()
end

-- Toggle menu visibility
function ZyncLib:ToggleVisibility()
    self.state.menuEnabled = not self.state.menuEnabled
    if self.state.menuEnabled then
        self:PlaySound("toggleOn")
    else
        self:PlaySound("toggleOff")
    end
    self.screenGui.Enabled = self.state.menuEnabled
end

-- Toggle minimized state
function ZyncLib:ToggleMinimized()
    self.state.minimized = not self.state.minimized
    self:PlaySound("click")
    self:Render()
end

-- Navigate through menu
function ZyncLib:Navigate(direction)
    if self.state.minimized then return end
    
    -- Play navigation sound
    self:PlaySound("nav")
    
    if self.state.selectedOption == 0 then
        -- On tab header
        if direction > 0 then
            -- Move to first option if tab is expanded, or next tab
            if self.state.expandedTabs[self.state.selectedTab] and #self.tabs[self.state.selectedTab].options > 0 then
                self.state.selectedOption = 1
            else
                self.state.selectedTab = self.state.selectedTab % #self.tabs + 1
            end
        else
            -- Move to previous tab
            self.state.selectedTab = (self.state.selectedTab - 2) % #self.tabs + 1
        end
    else
        -- On option
        if direction > 0 then
            -- Move to next option or next tab
            if self.state.selectedOption < #self.tabs[self.state.selectedTab].options then
                self.state.selectedOption = self.state.selectedOption + 1
            else
                self.state.selectedTab = self.state.selectedTab % #self.tabs + 1
                self.state.selectedOption = 0
            end
        else
            -- Move to previous option or tab header
            if self.state.selectedOption > 1 then
                self.state.selectedOption = self.state.selectedOption - 1
            else
                self.state.selectedOption = 0
            end
        end
    end
    
    self:Render()
end

-- Cycle option value
function ZyncLib:CycleOptionValue(tabIndex, optionIndex)
    local option = self.tabs[tabIndex].options[optionIndex]
    
    if option.type == "button" then
        -- Execute button callback
        if option.callback then
            option.callback()
        end
        self:PlaySound("click")
        return
    end
    
    -- For toggles and dropdowns
    if option.values then
        -- Find current value index
        local currentIndex = 1
        for i, val in ipairs(option.values) do
            if val == option.value then
                currentIndex = i
                break
            end
        end
        
        -- Cycle to next value
        currentIndex = currentIndex % #option.values + 1
        option.value = option.values[currentIndex]
        
        -- Handle script execution based on value
        if option.scriptId and option.onScript then
            local isOn = string.find(option.value, "ON") ~= nil or 
                        (option.value ~= "« OFF" and option.value ~= "«OFF»")
            
            if isOn then
                self.scriptManager:RunScript(option.scriptId, option.onScript, option.offScript)
                self:PlaySound("toggleOn")
            else
                self.scriptManager:StopScript(option.scriptId)
                self:PlaySound("toggleOff")
            end
        else
            -- If no script, just play the toggle sound
            if string.find(option.value or "", "ON") ~= nil then
                self:PlaySound("toggleOn")
            else
                self:PlaySound("toggleOff")
            end
        end
        
        -- Call callback if exists
        if option.callback then
            option.callback(option.value)
        end
    end
    
    self:Render()
end

-- Open keybind dropdown
function ZyncLib:OpenKeybindDropdown(tabIndex, optionIndex)
    -- Clear dropdown
    for _, child in pairs(self.keybindDropdown:GetChildren()) do
        child:Destroy()
    end
    
    local option = self.tabs[tabIndex].options[optionIndex]
    local optionFrame = self.menuContainer:FindFirstChild("OptionFrame_" .. tabIndex .. "_" .. optionIndex)
    
    if not optionFrame then return end
    
    -- Position dropdown near option
    local absPos = optionFrame.AbsolutePosition
    self.keybindDropdown.Position = UDim2.new(0, absPos.X + optionFrame.AbsoluteSize.X - 50, 0, absPos.Y + 25)
    
    -- Create dropdown title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    title.BorderSizePixel = 0
    title.Size = UDim2.new(1, 0, 0, 20)
    title.Font = Enum.Font.RobotoMono
    title.Text = "Select Keybind"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 14
    title.ZIndex = 1101
    title.Parent = self.keybindDropdown
    
    -- Create keybind options container
    local listFrame = Instance.new("Frame")
    listFrame.Name = "ListFrame"
    listFrame.BackgroundTransparency = 1
    listFrame.Position = UDim2.new(0, 0, 0, 20)
    listFrame.Size = UDim2.new(1, 0, 1, -20)
    listFrame.ZIndex = 1101
    listFrame.Parent = self.keybindDropdown
    
    -- Create keybind options
    for i, key in ipairs(self.commonKeybinds) do
        local item = Instance.new("TextButton")
        item.Name = "Key_" .. key
        item.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        item.BorderSizePixel = 0
        item.Position = UDim2.new(0, 0, 0, (i-1) * 20)
        item.Size = UDim2.new(1, 0, 0, 20)
        item.Font = Enum.Font.RobotoMono
        item.Text = key
        item.TextColor3 = Color3.fromRGB(255, 255, 255)
        item.TextSize = 14
        item.ZIndex = 1101
        
        -- Highlight current keybind
        if option.keybind == key then
            item.BackgroundColor3 = HIGHLIGHT_COLOR
        end
        
        -- Keybind selection handling
        item.MouseButton1Click:Connect(function()
            option.keybind = key
            self:PlaySound("click")
            self.keybindDropdown.Visible = false
            self.state.keybindOpen = false
            self:Render()
        end)
        
        -- Hover effect for keybind options
        item.MouseEnter:Connect(function()
            if self.state.lastHoveredElement ~= item then
                self:PlaySound("hover")
                self.state.lastHoveredElement = item
                
                -- Add slight highlight on hover
                if option.keybind ~= key then
                    item.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                end
            end
        end)
        
        item.MouseLeave:Connect(function()
            -- Reset background when not hovering
            if option.keybind ~= key then
                item.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            end
        end)
        
        item.Parent = listFrame
    end
    
    -- Set dropdown size and show
    self.keybindDropdown.Size = UDim2.new(0, 120, 0, 20 + (#self.commonKeybinds * 20))
    self.keybindDropdown.Visible = true
    self.state.keybindOpen = true
end

-- Render the UI
function ZyncLib:Render()
    -- Clear menu container
    for _, child in pairs(self.menuContainer:GetChildren()) do
        child:Destroy()
    end
    
    -- Close keybind dropdown if open
    if self.state.keybindOpen then
        self.keybindDropdown.Visible = false
        self.state.keybindOpen = false
    end
    
    -- Handle minimized state
    if self.state.minimized then
        self.mainFrame.Size = UDim2.new(0, self.width, 0, 25)
        self.menuContainer.Visible = false
        return
    else
        self.menuContainer.Visible = true
    end
    
    -- Create menu items
    local yOffset = 0
    
    for tabIndex, tab in ipairs(self.tabs) do
        -- Create tab header with animated arrow
        local tabFrame = Instance.new("Frame")
        tabFrame.Name = "TabFrame_" .. tabIndex
        tabFrame.BackgroundTransparency = 1
        tabFrame.Position = UDim2.new(0, 0, 0, yOffset)
        tabFrame.Size = UDim2.new(1, 0, 0, 20)
        tabFrame.ZIndex = 1001
        tabFrame.Parent = self.menuContainer
        
        local arrowContainer = Instance.new("Frame")
        arrowContainer.Name = "ArrowContainer"
        arrowContainer.BackgroundTransparency = 1
        arrowContainer.Size = UDim2.new(0, 20, 0, 20)
        arrowContainer.ZIndex = 1002
        arrowContainer.Parent = tabFrame
        
        local arrow = Instance.new("TextLabel")
        arrow.Name = "Arrow"
        arrow.BackgroundTransparency = 1
        arrow.Position = UDim2.new(0.5, 0, 0.5, 0)
        arrow.Size = UDim2.new(0, 20, 0, 20)
        arrow.AnchorPoint = Vector2.new(0.5, 0.5)
        arrow.Font = Enum.Font.RobotoMono
        arrow.Text = "►" -- Default right arrow (when closed)
        arrow.TextColor3 = self.state.expandedTabs[tabIndex] and HIGHLIGHT_COLOR or COLOR3.new(1,1,1)
        arrow.TextSize = 14
        arrow.Rotation = self.state.expandedTabs[tabIndex] and 90 or 0 -- Rotated when expanded (pointing down)
        arrow.ZIndex = 1003
        arrow.Parent = arrowContainer
        
        local tabHeader = Instance.new("TextLabel")
        tabHeader.Name = "Header"
        tabHeader.BackgroundTransparency = 1
        tabHeader.Position = UDim2.new(0, 20, 0, 0)
        tabHeader.Size = UDim2.new(1, -20, 1, 0)
        tabHeader.Font = Enum.Font.RobotoMono
        tabHeader.ZIndex = 1002
        
        -- Format tab header based on selection
        if self.state.selectedTab == tabIndex and self.state.selectedOption == 0 then
            tabHeader.Text = "_« " .. tab.name .. " _"
            tabHeader.TextColor3 = HIGHLIGHT_COLOR
            arrow.TextColor3 = HIGHLIGHT_COLOR
        else
            tabHeader.Text = "_« " .. tab.name .. " _"
            tabHeader.TextColor3 = DEFAULT_TEXT_COLOR
        end
        
        tabHeader.TextSize = 16
        tabHeader.TextXAlignment = Enum.TextXAlignment.Left
        tabHeader.Parent = tabFrame
        
        -- Tab Click handling
        tabFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                self.state.selectedTab = tabIndex
                self.state.selectedOption = 0
                self.state.expandedTabs[tabIndex] = not self.state.expandedTabs[tabIndex]
                self:PlaySound("click")
                self:Render()
            end
        end)
        
        -- Tab hover sound
        tabFrame.MouseEnter:Connect(function()
            if self.state.lastHoveredElement ~= tabFrame then
                self:PlaySound("hover")
                self.state.lastHoveredElement = tabFrame
            end
        end)
        
        yOffset = yOffset + 20
        
        -- Add options if tab is expanded
        if self.state.expandedTabs[tabIndex] then
            for optionIndex, option in ipairs(tab.options) do
                local optionFrame = Instance.new("Frame")
                optionFrame.Name = "OptionFrame_" .. tabIndex .. "_" .. optionIndex
                optionFrame.BackgroundTransparency = 1
                optionFrame.Position = UDim2.new(0, 20, 0, yOffset)
                optionFrame.Size = UDim2.new(1, -20, 0, 20)
                optionFrame.ZIndex = 1001
                optionFrame.Parent = self.menuContainer
                
                local optionLabel = Instance.new("TextLabel")
                optionLabel.Name = "OptionLabel"
                optionLabel.BackgroundTransparency = 1
                optionLabel.Size = UDim2.new(0.5, 0, 1, 0)
                optionLabel.Font = Enum.Font.RobotoMono
                optionLabel.ZIndex = 1001
                
                -- Check if this option is selected
                local isSelected = (self.state.selectedTab == tabIndex and self.state.selectedOption == optionIndex)
                
                if isSelected then
                    optionLabel.Text = "» " .. option.name
                    optionLabel.TextColor3 = HIGHLIGHT_COLOR
                else
                    optionLabel.Text = option.name
                    optionLabel.TextColor3 = UNSELECTED_COLOR
                end
                
                optionLabel.TextSize = 14
                optionLabel.TextXAlignment = Enum.TextXAlignment.Left
                optionLabel.Parent = optionFrame
                
                -- For options with values (toggles, dropdowns)
                if option.type ~= "button" then
                    local optionValue = Instance.new("TextLabel")
                    optionValue.Name = "OptionValue"
                    optionValue.BackgroundTransparency = 1
                    optionValue.Position = UDim2.new(0.5, 0, 0, 0)
                    optionValue.Size = UDim2.new(0.3, 0, 1, 0)
                    optionValue.Font = Enum.Font.RobotoMono
                    optionValue.Text = option.value
                    optionValue.ZIndex = 1001
                    
                    if isSelected then
                        optionValue.TextColor3 = HIGHLIGHT_COLOR
                    else
                        optionValue.TextColor3 = UNSELECTED_COLOR
                    end
                    
                    optionValue.TextSize = 14
                    optionValue.TextXAlignment = Enum.TextXAlignment.Left
                    optionValue.Parent = optionFrame
                end
                
                -- For button type
                if option.type == "button" then
                    -- Create a button indicator
                    local buttonIndicator = Instance.new("TextLabel")
                    buttonIndicator.Name = "ButtonIndicator"
                    buttonIndicator.BackgroundTransparency = 1
                    buttonIndicator.Position = UDim2.new(0.5, 0, 0, 0)
                    buttonIndicator.Size = UDim2.new(0.3, 0, 1, 0)
                    buttonIndicator.Font = Enum.Font.RobotoMono
                    buttonIndicator.Text = "[ CLICK ]"
                    buttonIndicator.ZIndex = 1001
                    
                    if isSelected then
                        buttonIndicator.TextColor3 = HIGHLIGHT_COLOR
                    else
                        buttonIndicator.TextColor3 = UNSELECTED_COLOR
                    end
                    
                    buttonIndicator.TextSize = 14
                    buttonIndicator.TextXAlignment = Enum.TextXAlignment.Left
                    buttonIndicator.Parent = optionFrame
                end
                
                -- Add keybind indicator if a keybind is set
                if option.keybind then
                    local keybindLabel = Instance.new("TextLabel")
                    keybindLabel.Name = "KeybindLabel"
                    keybindLabel.BackgroundTransparency = 1
                    keybindLabel.Position = UDim2.new(0.8, 0, 0, 0)
                    keybindLabel.Size = UDim2.new(0.2, 0, 1, 0)
                    keybindLabel.Font = Enum.Font.RobotoMono
                    keybindLabel.Text = "[" .. option.keybind .. "]"
                    keybindLabel.ZIndex = 1001
                    
                    if isSelected then
                        keybindLabel.TextColor3 = HIGHLIGHT_COLOR
                    else
                        keybindLabel.TextColor3 = KEYBIND_COLOR
                    end
                    
                    keybindLabel.TextSize = 12
                    keybindLabel.TextXAlignment = Enum.TextXAlignment.Right
                    keybindLabel.Parent = optionFrame
                end
                
                -- Option click handling
                optionFrame.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 then
                        self.state.selectedTab = tabIndex
                        self.state.selectedOption = optionIndex
                        self:CycleOptionValue(tabIndex, optionIndex)
                        self:Render()
                    elseif input.UserInputType == Enum.UserInputType.MouseButton2 and option.keybind then
                        self.state.selectedTab = tabIndex
                        self.state.selectedOption = optionIndex
                        self:PlaySound("click")
                        self:OpenKeybindDropdown(tabIndex, optionIndex)
                        self:Render()
                    end
                end)
                
                -- Option hover sound
                optionFrame.MouseEnter:Connect(function()
                    if self.state.lastHoveredElement ~= optionFrame then
                        self:PlaySound("hover")
                        self.state.lastHoveredElement = optionFrame
                    end
                end)
                
                yOffset = yOffset + 20
            end
        end
    end
    
    -- Update main frame size based on content
    if not self.state.minimized then
        local newHeight = math.max(yOffset + 30, 60) -- +30 for title area, minimum of 60px
        self.mainFrame.Size = UDim2.new(0, self.width, 0, newHeight)
        self.glowContainer.Size = UDim2.new(0, self.width + 8, 0, newHeight + 8)
    end
end

-- Return the library
return ZyncLib
